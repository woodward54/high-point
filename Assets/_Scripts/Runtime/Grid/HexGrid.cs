using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Threading.Tasks;
using System;
using System.Linq;
using Drawing;
using DG.Tweening;
using Pathfinding;
using Unity.VisualScripting;

public class HexGrid : Singleton<HexGrid>
{
    [field: SerializeField] public int Width { get; private set; }
    [field: SerializeField] public int Depth { get; private set; }
    [field: SerializeField] public float HexSize { get; private set; }
    [field: SerializeField] public float YStepSize { get; private set; }
    [field: SerializeField, Range(0f, 1f)] public float PrefabSize { get; private set; }
    [field: SerializeField] public HexOrientation Orientation { get; private set; }
    [field: SerializeField] public int BatchSize { get; private set; }
    [field: SerializeField] public Transform TileMods { get; private set; }

    public float HexTerrainSize { get { return HexSize * PrefabSize; } }

    // Dictionary<Vector3Int, HexCell> _cells = new();
    Dictionary<Vector2Int, HexCell> _cells = new();

    Task<Dictionary<Vector2Int, HexCell>> _hexGenerationTask;

    MapDataGenerator _mapGenerator;

    bool _cellDataGenerated = false;

    EventBinding<GameStateChangedEvent> GameStateChanged;

    // The following events are linked to map loading information
    // The Map Information has been generated by the task
    // public event Action OnMapInfoGenerated;
    // One of the batches has been successfully instantiated
    // public event Action<float> OnCellBatchGenerated;
    // All cell instantiation has been completed

    public static event Action OnTerrainFinalized;

    // public event Action OnCellInstancesGenerated;

    // Tmp
    [SerializeField] TerrainType Mountain;

    protected override void OnAwake()
    {
        _mapGenerator = MapDataGenerator.Instance;

        DOTween.Init(true, true, LogBehaviour.Default).SetCapacity(1250, 10);
    }

    void OnEnable()
    {
        GameStateChanged = new EventBinding<GameStateChangedEvent>(HandleGameStateChanged);
        Bus<GameStateChangedEvent>.Register(GameStateChanged);

        _mapGenerator.OnTerrainMapGenerated += SetHexCellTerrainTypes;

        HeightMapGenerator.Instance.OnNewHeightMapData += ProcessNewMeshScanData;
    }

    void OnDisable()
    {
        Bus<GameStateChangedEvent>.Unregister(GameStateChanged);

        _mapGenerator.OnTerrainMapGenerated -= SetHexCellTerrainTypes;

        HeightMapGenerator.Instance.OnNewHeightMapData -= ProcessNewMeshScanData;

        if (_hexGenerationTask != null && _hexGenerationTask.Status == TaskStatus.Running)
        {
            _hexGenerationTask.Dispose();
        }
    }

    void Update()
    {
        // Debug
        if (UiController.Instance.DebugMode)
        {
            using (Draw.ingame.WithColor(Color.green))
            {
                Draw.ingame.Cross(ApproxCenterOfGrid(), 0.4f);
            }
        }
    }

    void HandleGameStateChanged(GameStateChangedEvent @event)
    {
        switch (@event.State)
        {
            case GameState.Battle:
                FinalizeTerrain();
                break;
        }
    }

    void ProcessNewMeshScanData(int[,] heightMap)
    {
        if (!_cellDataGenerated) return;

        for (int x = 0; x < Width; x++)
        {
            for (int z = 0; z < Depth; z++)
            {
                if (heightMap[x, z] == (int)HeightMapGenerator.RAYCAST_MISS) continue;

                CreateOrUpdateCell(x, heightMap[x, z], z);
            }
        }
    }

    void FinalizeTerrain()
    {
        // HeightMapGenerator.Instance.FinalizeHeightMap();
        // var heightMap = HeightMapGenerator.Instance.HeightMapFiltered;
        // for (int x = 0; x < Width; x++)
        // {
        //     for (int z = 0; z < Depth; z++)
        //     {
        //         CreateOrUpdateCell(x, heightMap[x, z], z);
        //     }
        // }

        OnTerrainFinalized?.Invoke();
    }

    void CreateOrUpdateCell(int x, int y, int z)
    {
        var cell = _cells[new Vector2Int(x, z)];

        var coords = new Vector3Int(x, y, z);

        // if (y == (int)HeightMapGenerator.WALL)
        // {
        //     coords.y = 0;
        //     cell.SetTerrainType(Mountain);
        // }

        // No change in y detected, skip
        if (cell.OffsetCoordinates == coords) return;

        cell.SetCoordinates(coords);

        if (cell.Terrain == null)
        {
            cell.CreateTerrain();
            cell.ChangeState(new VisibleState());
        }
        else
        {
            cell.UpdateTerrain();
        }
    }

    void SetHexCellTerrainTypes(TerrainType[,] terrainMap)
    {
        ClearHexCells();

        var gridYPos = transform.position.y;

        _hexGenerationTask = Task.Run(() => GenerateHexCellData(terrainMap, gridYPos));
        _hexGenerationTask.ContinueWith(task =>
        {
            _cells = task.Result;

            _cellDataGenerated = true;

            // MainThreadDispatcher.Instance.Enqueue(() => StartCoroutine(InstantiateCells(_cells)));
        });
    }

    // No Unity API allowed - including looking up transform data, Instantiation, etc.
    Dictionary<Vector2Int, HexCell> GenerateHexCellData(TerrainType[,] terrainMap, float gridYPos)
    {
        Dictionary<Vector2Int, HexCell> hexCells = new();

        for (int x = 0; x < Width; x++)
        {
            for (int z = 0; z < Depth; z++)
            {
                try
                {
                    // Y value will get set later in ProcessNewMeshScanData
                    var unsetYValue = -1000;
                    var coords = new Vector3Int(x, unsetYValue, z);

                    // int flippedX = Width - x - 1;
                    // int flippedZ = Depth - z - 1;

                    HexCell cell = new();
                    cell.SetCoordinates(coords);
                    cell.SetTerrainType(terrainMap[x, z]);

                    hexCells.Add(new Vector2Int(x, z), cell);
                }
                catch (Exception ex)
                {
                    Debug.LogException(ex, this);
                }
            }
        }

        SetNeighbors(hexCells);

        return hexCells;
    }

    // Handled by coroutine and currently the most expensive operation
    // IEnumerator InstantiateCells(Dictionary<Vector2Int, HexCell> hexCells)
    // {
    //     int batchCount = 0;
    //     int totalBatches = Mathf.CeilToInt(hexCells.Count / BatchSize);
    //     var cells = _cells.ToList();
    //     for (int i = 0; i < cells.Count; i++)
    //     {
    //         var cell = cells[i].Value;

    //         cell.CreateTerrain();
    //         cell.ChangeState(new VisibleState());

    //         // Yield every batchSize hex cells
    //         if (i % BatchSize == 0 && i != 0)
    //         {
    //             batchCount++;
    //             OnCellBatchGenerated?.Invoke((float)batchCount / totalBatches);
    //             yield return null;
    //         }
    //     }

    //     _cellsInstantiated = true;
    //     OnCellInstancesGenerated?.Invoke();
    // }

    public void SetNeighbors(Dictionary<Vector2Int, HexCell> cells)
    {
        var cellList = cells.Values.ToList();
        foreach (HexCell cell in cellList)
        {
            List<HexCell> neighbors = new List<HexCell>();
            // Get the axial coordinates of the current cell
            Vector2 currentAxialCoordinates = cell.AxialCoordinates;

            // Get the neighbor directions for the current cell
            List<Vector2> neighborCoordinates = HexUtils.GetNeighborCoordinatesList(currentAxialCoordinates);
            int neighborsFound = 0;
            foreach (Vector2 neighborCoord in neighborCoordinates)
            {
                // Find the neighbor cell based on the direction
                HexCell neighbor = cellList.Find(c => c.AxialCoordinates == neighborCoord);

                // If the neighbor exists, add it to the Neighbors list
                if (neighbor != null)
                {
                    neighbors.Add(neighbor);
                    neighborsFound++;
                }
            }

            cell.SetNeighbors(neighbors);
        }
    }

    public void ClearHexCells()
    {
        var cells = _cells.ToList();
        for (int i = 0; i < cells.Count; i++)
        {
            cells[i].Value.ClearTerrain();
        }

        _cells.Clear();
    }

    public List<IGrouping<int, HexCell>> GetCellRegionsByHeight()
    {
        var cells = _cells.Values.ToList().Where(c => c.Terrain != null);

        return cells.GroupBy(c => c.OffsetCoordinates.y).ToList();
    }

    public HexCell GetNearest(Vector3 position)
    {
        var gridPos = position - transform.position;
        var coords = HexUtils.CoordinateToOffset(gridPos, HexSize, Orientation);
        return _cells.Values.Where(c =>
                            c.OffsetCoordinates.x == coords.x &&
                            c.OffsetCoordinates.z == coords.y).First();
    }

    public HexCell GetCell(Vector3Int coords)
    {
        if (_cells.TryGetValue(new Vector2Int(coords.x, coords.z), out var hexCell))
        {
            return hexCell;
        }
        else
        {
            Debug.LogWarning("Trying to GetCell that doesn't exist at " + coords.ToString());
            return null;
        }
    }

    public HexCell GetCell(int x, int z)
    {
        // There should only be 1 cell per (x, y) pair
        foreach (var item in _cells)
        {
            if (item.Key.x == x && item.Key.y == z) return item.Value;
        }

        Debug.LogWarning("Trying to GetCell that doesn't exist at (" + x + ", " + z + ")");
        return null;
    }

    public Vector3 GetHexPosition(Vector3Int offsetCoords)
    {
        var c = HexUtils.Center(HexSize, offsetCoords, Orientation, false);
        c.y = YStepSize * offsetCoords.y;

        return c + transform.position;
    }

    // public Vector3 GetHexPosition(HexCell cell)
    // {

    // }

    public bool InRange((int, int) coord)
    {
        return InRange(coord.Item1, coord.Item2);
    }

    public bool InRange(int x, int z)
    {
        return x >= 0 && x < Width && z >= 0 && z < Depth;
    }

    public bool OnOuterEdge((int, int) coord)
    {
        return OnOuterEdge(coord.Item1, coord.Item2);
    }

    public bool OnOuterEdge(int x, int z)
    {
        return x == 0 || x == Width - 1 || z == 0 || z == Depth - 1;
    }

    public Vector3 ApproxCenterOfGrid()
    {
        var centerNode = new Vector3Int(Width / 2, 0, Depth / 2);
        var center = GetHexPosition(centerNode);
        center.y = transform.position.y;
        return center;
    }

    public void SetGridCenter(Vector3 center)
    {
        // Approx grid width
        var currentCenter = ApproxCenterOfGrid();
        var approxDiff = currentCenter - transform.position;

        // Bottom left of the grid
        var newBottomLeft = center - approxDiff;
        newBottomLeft.y = center.y;
        transform.position = newBottomLeft;
    }

    // void g()
    // {
    //     for (int x = 0; x < Width; x++)
    //     {
    //         for (int z = 0; z < Depth; z++)
    //         {
    //             var coords = new Vector3Int(x, 0, z);
    //             var center = HexUtils.Center(HexSize, coords, Orientation);
    //             var corners = HexUtils.Corners(HexSize, Orientation);
    //             for (int s = 0; s < corners.Length; s++)
    //             {
    //                 Gizmos.DrawLine(
    //                     center + corners[s % 6],
    //                     center + corners[(s + 1) % 6]
    //                 );
    //             }
    //         }
    //     }
    // }
}

public enum HexOrientation
{
    FlatTop,
    PointyTop
}